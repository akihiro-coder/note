# jupyter notebookでvim keybindを使う方法
- 以下のリンクに沿って、インストールのアクティベートをする
- [installation-jupyter-vim-keybind](https://github.com/lambdalisue/jupyter-vim-binding#installation)
- [注意] python -m pip install notebook==6.1.5 をしないと、アクティベートコマンドのjupyter nvextension が使えない

# pythonの実行方法
- 環境変数PATHの先頭に書いてあるパス内にあるpythonが実行される
    - PATHの先頭のパスからpython実行ファイルを検索
    - あれば、その実行ファイルが実行される　
```sh
python file.py
```

- /usr/bin/python　が実行される
    - このように明示的に実行ファイルを指定することもできる
```sh
/usr/bin/python file.py
```



# 仮想環境venvについて深堀り
- コマンド：source venv/bin/activateがしていることが明確になった
- 参考リンク　→　[pythonの仮想環境を完全に理解しよう](https://speakerdeck.com/os1ma/pythonno-jia-xiang-huan-jing-wowan-quan-nili-jie-siyou)


# venv以外のバージョン管理とパッケージ管理の方法
- pythonパッケージ管理とpythonのバージョン管理をしたい場合は、pyenv + pyenv-virtualenvを使うといい。
- 参考リンク　→　[pyenvでのpython仮想環境の作り方まとめ](https://qiita.com/ysdyt/items/5008e607343b940b3480#pyenv-global-%E3%81%A8-pyenv-local )


# dequeでキュー、スタック、デックを扱う
- 参考リンク　→　[pythonのキュー、スタック、デックを扱う](https://note.nkmk.me/python-collections-deque/)
- list型とdeque型の違い
    - 要素の追加、取り消し（削除）、アクセス（取得）が両端のみ -> deque
    - 両端以外の要素に頻繁にアクセス　-> list
- 明確にキューやスタック、デックとしてデータを扱いたい、という場合は dequeを使ったほうがよい。
- ただ、環境や条件にもよるが、要素数が数百個や数千個程度であれば、リストでもdequeでも体感できるほどの処理速度の差はない。ミリ秒オーダーで処理時間を切り詰めたいアプリケーションや競技プログラミングでもない限り、多くの場合はリストを使っていても特に問題はないはず。
- とはいえ、リストは先頭に要素を追加したり先頭の要素を削除したりするのが遅い、dequeは中央部分の要素へのアクセスが遅い、といったことは頭に入れておくといいだろう。


# Ubuntu環境でのpipコマンドの仕様について
- ~/.local/にインストールしたい場合は、python3 -m pip install
- /usr/local/libにインストールしたい場合は、sudo python3 -m pip install
- 参考資料　→　[pip-python.jp](https://www.python.jp/install/ubuntu/pip.html )
> 通常、pipコマンドでパッケージをインストールすると、/usr/local/lib/ などの、全ユーザが参照できる、Pythonの共有モジュール格納ディレクトリにインストールされます。
> しかし、--user オプションを指定すると、~/.local/ などのそれぞれのユーザ個別の専用ディレクトリにインストールされ、他のユーザに影響を与えずに自由にパッケージのインストールや削除ができます。
> Debian パッケージの pip コマンド (python3-pip/python-pip) では、--user オブションのデフォルト値が変更されており、特権ユーザではない、一般ユーザとして pip install コマンドを実行すると、自動的に --user オプションが指定されたのもとして実行します。
> このため、Ubuntu版の pip コマンドを使用する場合、非特権ユーザが pip install を実行すると、ホームディレクトリの ~/.local ディレクトリにインストールされます。
> sudo pip3 install xxx のように、特権ユーザとしてコマンドを実行した場合には、/usr/local/lib にインストールされます。


# python GILについて
- ChatGPTより
> GIL（Global Interpreter Lock）は、Pythonインタプリタが保持する一種のロックであり、Pythonのマルチスレッドプログラミングに影響を与える重要な概念です。GILは、Pythonのスレッドが同時に1つの命令を実行できるように制御するために存在します。
> 具体的には、Pythonの実行中には1つのスレッドしかPythonのバイトコード（Pythonコードの実行形式）を実行できず、他のスレッドは待機状態に入ることがあります。このため、CPUバウンドな処理（CPUを多く使用する処理）を行う際には、マルチスレッドを利用してもパフォーマンスの向上が制限されることがあります。
> ただし、IOバウンドな処理（入出力待ちを多く行う処理）においては、GILの影響が小さいです。なぜなら、IO処理ではCPUをほとんど使用しないため、スレッドが待機状態に入ることが少ないからです。
> PythonのGILは、マルチプロセスを使用することで回避できる場合もあります。`multiprocessing`モジュールを使って複数のプロセスを生成し、それぞれのプロセスでPythonのインタプリタが独立して動作するため、GILの影響を受けずにマルチコアを活用できます。

# python ロックについて
- ChatGPTより
> ロック（Lock）は、プログラム内の一部のコードやデータへのアクセスを制御するための仕組みです。複数のスレッドやプロセスが同時にアクセスする可能性がある共有リソースへのアクセスを制御するために使用されます。
> ロックは、競合状態（複数のスレッドやプロセスが同時にデータにアクセスし、データの整合性が崩れる状態）を防ぐために重要です。複数のスレッドやプロセスが同じデータに同時にアクセスすると、予期せぬ結果やエラーが発生する可能性があります。ロックを使用することで、一度に1つのスレッドやプロセスだけが保護されたリソースにアクセスできるようになり、データの整合性を保つことができます。
> 一般的なロックの種類には次のようなものがあります：
> ミューテックス（Mutex）: 1つのスレッドやプロセスがロックを獲得し、保護されたリソースにアクセスできるようにします。他のスレッドやプロセスはロックが解放されるのを待つ必要があります。
> セマフォ（Semaphore）: 複数のスレッドやプロセスが同時にアクセスできる数を制御するための仕組みです。ある数のスレッドだけが同時に実行されることを許可する場合に使用されます。
> リード・ライトロック（Read-Write Lock）: 複数のスレッドが同時にデータを読むことを許可し、一方がデータを書き込む際には排他制御を行う仕組みです。
> ロックは正しく使わないとデッドロック（相互にロックし合って進行が止まる状態）やロック競合（多数のスレッドが同時にロックを取り合う状態）の問題を引き起こす可能性があるため、適切な使用方法に気を付ける必要があります。
